{
    scopeName = 'injection.ansible.jinja-conditionals';
    name = 'Grammar for Jinja2 expressions in Ansible conditionals';
    patterns = (
        { include = '#ansible-condition'; }
    );
    comment = (
        'Flow style collections are not supported (yet)',
        'Proper YAML comment highlighting will not work in nested Jinja expressions. For example:
            when: condition1 # this works
                or condition2
            
            when: (condition1 # this will not work
                or condition2)
        It is impossible to implement that with TM grammars, without modifying the Jinja grammar itself.
        ',
    );
    repository = {
        ansible-condition = {
            patterns = (
                {
                    name = 'meta.flow.ansible.condition';
                    begin = '(?x)
                        ^(\s*) # 1
                        (?:(-)(\s+))? # 2, 3; in case it is first key of a list item
                        \b( # 4
                            changed_when
                            | failed_when
                            | when
                            | check_mode
                        )\b
                        \s* (:) # 5
                        \s+ (?![|>]|\s*$) # not starting a block (scalar or other)
                    ';
                    beginCaptures = {
                        2 = {
                            name = 'punctuation.definition.block.sequence.item.ansible';
                        };
                        4 = {
                            name = 'keyword.other.special-method.ansible';
                        };
                        5 = {
                            name = 'punctuation.separator.key-value.mapping.ansible';
                        };
                    };
                    end = '(?x)
                        ^(?!\1\3\3\s+) # if the indentation is too small; HACK: \3 is used twice to match at least 2 spaces if group 2 matches
                    ';
                    patterns = (
                        { include = 'source.ansible#comment'; },
                        { include = '#yaml-quoted-string'; },
                        { include = '#yaml-unquoted-string'; }
                    );
                },
                {
                    name = 'meta.block-scalar.ansible.condition';
                    comment = (
                        'Keyword detection'
                    );
                    begin = '(?x)
                        ^(\s*) # 1
                        (?:(-)(\s+))? # 2, 3; in case it is first key of a list item
                        \b( # 4
                            changed_when
                            | failed_when
                            | when
                            | check_mode
                        )\b
                        \s* (:) # 5
                        \s+ (?: (\|) | (>) ) ([1-9])? ([-+])? # 6,7,8,9; starting a scalar block
                    ';
                    beginCaptures = {
                        2 = {
                            name = 'punctuation.definition.block.sequence.item.ansible';
                        };
                        4 = {
                            name = 'keyword.other.special-method.ansible';
                        };
                        5 = {
                            name = 'punctuation.separator.key-value.mapping.ansible';
                        };
                        6 = {
                            name = 'keyword.control.flow.block-scalar.literal.ansible';
                        };
                        7 = {
                            name = 'keyword.control.flow.block-scalar.folded.ansible';
                        };
                        8 = {
                            name = 'constant.numeric.indentation-indicator.ansible';
                        };
                        9 = {
                            name = 'storage.modifier.chomping-indicator.ansible';
                        };
                    };
                    end = '(?x)
                        ^(?!\1\3\3\s+) # if the indentation is too small; HACK: \3 is used twice to match at least 2 spaces if group 2 matches
                    ';
                    patterns = (
                        { include = '#yaml-scalar-block'; },
                    );
                },
                {
                    name = 'meta.block.ansible.condition';
                    comment = (
                        'Keyword detection'
                    );
                    begin = '(?x)
                        ^(\s*) # 1
                        (?:(-)(\s+))? # 2, 3; in case it is first key of a list item
                        \b( # 4
                            changed_when
                            | failed_when
                            | when
                            | check_mode
                        )\b
                        \s* (:) # 5
                        \s*$ # starting other block
                    ';
                    beginCaptures = {
                        2 = {
                            name = 'punctuation.definition.block.sequence.item.ansible';
                        };
                        4 = {
                            name = 'keyword.other.special-method.ansible';
                        };
                        5 = {
                            name = 'punctuation.separator.key-value.mapping.ansible';
                        };
                    };
                    end = '(?x)
                        ^(?!\1\3\3\s+) # if the indentation is too small; HACK: \3 is used twice to match at least 2 spaces if group 2 matches
                    ';
                    patterns = (
                        { include = '#yaml-block'; },
                    );
                }
            );
        };
        yaml-block = {
            patterns = (
                {
                    name = 'meta.yaml-block.ansible.condition';
                    comment = (
                        'Well-indented block; possibly list'
                    );
                    begin = '(?x)
                        ^(\s*) # 1
                        (?:(-)(\s+))? # 2, 3; in case it a list item
                    ';
                    beginCaptures = {
                        2 = {
                            name = 'punctuation.definition.block.sequence.item.ansible';
                        };
                    };
                    end = '(?x)
                        ^(?!\1\3\3\s+) # if the indentation is too small; HACK: \3 is used twice to match at least 2 spaces if group 2 matches
                    ';
                    patterns = (
                        { include = 'source.ansible#comment'; },
                        { include = '#yaml-quoted-string'; },
                        { include = '#yaml-unquoted-string'; }
                    );
                }
            );
        };
        yaml-scalar-block = {
            patterns = (
                {
                    name = 'meta.yaml-block.ansible.condition';
                    comment = (
                        'Well-indented scalar block (for `>` and `|`)'
                    );
                    begin = '(?x)
                        ^(\s*) # 1
                    ';
                    end = '(?x)
                        ^(?!\1\s+) # if the indentation is too small
                    ';
                    contentName = 'variable.other.constant.ansible variable.language meta.embedded.inline.jinja';
                    patterns = (
                        { include = '#yaml-unquoted-string'; },
                    );
                }
            );
        };
        yaml-quoted-string = {
            patterns = (
                {
                    name = 'meta.quoted-string.ansible.condition';
                    begin = '["'']';
                    beginCaptures = {
                        0 = {
                            name = 'punctuation.definition.string.begin.ansible';
                        };
                    };
                    end = '(?x)
                        (\0) # 1; match the starting quote (TODO: add illegals matching)
                    ';
                    endCaptures = {
                        1 = {
                            name = 'punctuation.definition.string.end.ansible';
                        };
                    };
                    contentName = 'variable.other.constant.ansible variable.language meta.embedded.inline.jinja';
                    patterns = (
                        { include = 'source.jinja#expression'; },
                    );
                }
            );
        };
        yaml-unquoted-string = {
            patterns = (
                {
                    comment = 'Capture any non-whitespace and end as fast as possible (when inner pattern ends)';
                    name = 'meta.unquoted-string.ansible.condition';
                    begin = '(?=\S)';
                    end = '(?!\G)';
                    contentName = 'variable.other.constant.ansible variable.language meta.embedded.inline.jinja';
                    patterns = (
                        { include = 'source.jinja#expression'; },
                    );
                }
            );
        };
    };
}